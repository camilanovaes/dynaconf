
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <title>) &#8212; dynaconf 3.0.0rc2 documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="&lt;no title&gt;" href="sensitive_secrets.html" />
    <link rel="prev" title="Dynaconf - Easy and Powerful Settings Configuration for Python" href="../index.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p># Getting Started</p>
<p>## Installation</p>
<p>&gt; Python 3.x is required</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">$</span> <span class="pre">pip</span> <span class="pre">install</span> <span class="pre">dynaconf</span>
<span class="pre">`</span></code></p>
<p>&gt; Default installation supports .toml, .py and .json file formats and also environment variables (.env supported) - to support YAML add <cite>pip install dynaconf[yaml]</cite> or <cite>pip install dynaconf[all]</cite></p>
<p>## Usage</p>
<p>### Accessing config variables in your Python application</p>
<p>In your Python program wherever you need to access a settings variable you use the canonical object <cite>from dynaconf import settings</cite>:</p>
<p>#### Example of program to connect to some database</p>
<p><a href="#id1"><span class="problematic" id="id2">``</span></a><a href="#id3"><span class="problematic" id="id4">`</span></a>python
from some.db import Client</p>
<p>from dynaconf import settings</p>
<dl class="simple">
<dt>conn = Client(</dt><dd><p>username=settings.USERNAME,             # attribute style access
password=settings.get(‘PASSWORD’),      # dict get style access
port=settings[‘PORT’],                  # dict item style access
timeout=settings.as_int(‘TIMEOUT’),     # Forcing casting if needed
host=settings.get(‘HOST’, ‘localhost’)  # Providing defaults</p>
</dd>
</dl>
<div class="section" id="id5">
<h1>)<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h1>
<p>### Understanding the settings</p>
<p>Dynaconf aims to have a flexible and usable configuration system. Your applications can be configured via a [<strong>configuration files</strong>](#the-settings-files), through [<strong>environment variables</strong>](environment_variables.html), or both. Configurations can be separated into environments: <strong>[default], [development], [staging], [testing] and [production]</strong>. The working environment is switched via an environment variable.</p>
<p>But this is all <strong>optional</strong> you can of course follow strictly the [12 factor app](<a class="reference external" href="https://12factor.net/config">https://12factor.net/config</a>) guide, have your configuration coming only from environment variables and provide files only to store <cite>[default]</cite> values. (take also a look on how to add a [dynaconf validation](validation.html) file to your project).</p>
<p><strong>Sensitive data</strong> like tokens, secret keys and password can be stored in <cite>.secrets.*</cite> files and/or [external storages](external_storages.html) like <cite>Redis</cite> or <cite>vault</cite> secrets server.</p>
<p>Besides the built-in optional support to <strong>Redis</strong> as settings storage dynaconf allows you to create [<strong>Custom Loaders</strong>](extend.html) and store the data wherever you want e.g: databases, memory storages, other file formats, nosql databases etc.</p>
<p>## Working environments</p>
<p>At any point in time, your application is operating in a given configuration environment. By default there are four such environments:</p>
<ul class="simple">
<li><p>[development] (selected by default)</p></li>
<li><p>[staging]</p></li>
<li><p>[testing]</p></li>
<li><p>[production]</p></li>
<li><p>[{custom}] &lt;– You can create named environments that you need</p></li>
</ul>
<p>&gt; There is also the pseudo-envs <strong>[default]</strong> to provide comprehensive default values and <strong>[global]</strong> to provide global values to override in any other environment.</p>
<p>Without any action, your applications by default run in the <strong>[development]</strong> environment. The environment can be changed via the <cite>ENV_FOR_DYNACONF</cite> environment variable. For example, to launch an application in the <strong>[staging]</strong> environment, we can run:</p>
<p><code class="docutils literal notranslate"><span class="pre">`bash</span>
<span class="pre">export</span> <span class="pre">ENV_FOR_DYNACONF=staging</span>
<span class="pre">`</span></code></p>
<p>or</p>
<p><code class="docutils literal notranslate"><span class="pre">`bash</span>
<span class="pre">ENV_FOR_DYNACONF=staging</span> <span class="pre">python</span> <span class="pre">yourapp.py</span>
<span class="pre">`</span></code></p>
<p>&gt; <strong>NOTE:</strong> When using [Flask Extension](flask.html) the environment can be changed via <cite>FLASK_ENV</cite> variable and for [Django Extension](django.html) you can use <cite>DJANGO_ENV</cite>.</p>
<p>## Disabling Working environments</p>
<p>In some cases you might want to disable the layered environment separation and just load everything from a file use:</p>
<p><code class="docutils literal notranslate"><span class="pre">`bash</span>
<span class="pre">export</span> <span class="pre">ENVLESS_MODE_FOR_DYNACONF=true</span>
<span class="pre">`</span></code></p>
<p>or pass this setting to your own Dynaconf instance</p>
<p><a href="#id6"><span class="problematic" id="id7">``</span></a><a href="#id8"><span class="problematic" id="id9">`</span></a>py
from dynaconf import LazySettings</p>
<p>settings = LazySettings(ENVLESS_MODE=True)
<a href="#id10"><span class="problematic" id="id11">``</span></a><a href="#id12"><span class="problematic" id="id13">`</span></a></p>
<p>## The settings files</p>
<p>&gt; <strong>NOTE:</strong> The settings files are optional. If it is not present, only the values from <strong>environment variables</strong> and enabled external loaders are used (<strong>.env</strong> file is also supported).</p>
<p>Dynaconf will search for the settings files defined in <cite>SETTINGS_FILE_FOR_DYNACONF</cite> which by default is a list containing combinations of <strong>settings.{py|toml|json|ini|yaml}</strong> and <strong>.secrets.{py|toml|json|ini|yaml}</strong>
and dynaconf will try to find each one of those combinations, optionally it is possible to configure it to a different set of files e.g: <cite>export SETTINGS_FILE_FOR_DYNACONF=’[“myfilename.toml”, “another.json”]’</cite>, this value contains a list of relative or absolute paths, can be a toml-like list or a comma/semicolon separated string and can be exported to <cite>envvars</cite>, write to <cite>.env</cite> file or passed directly to Dynaconf instance.</p>
<p>&gt; IMPORTANT: Dynaconf by default reads settings files using <cite>utf-8</cite> encoding, if you have settings files written in other encoding please set <cite>ENCODING_FOR_DYNACONF</cite> environment variable.</p>
<p>See more details in [configuration](configuration.html)</p>
<p>## Settings files location</p>
<p>To find the files defined in <cite>SETTINGS_FILE_FOR_DYNACONF</cite> the search will start at the path defined in <cite>ROOT_PATH_FOR_DYNACONF</cite> (if defined), then will recursively walk to its root and then will try the <strong>folder where the called program is located</strong> and then it will recursively try its parent directories <strong>until the root parent is reached which can be File System `/` or the current working dir</strong> then finally will try the <strong>current working directory</strong> as the last option.</p>
<p>&gt; <strong>NOTE</strong>: If by any reason you need Dynaconf to first look at the current working dir you can customize the <cite>ROOT_PATH_FOR_DYNACONF</cite> via environment variable or by creating a [custom settings object](advanced_usage.html#customizing-the-settings-object)</p>
<p>Some people prefer to put settings in a sub-folder so for each of the paths it will also search in a relative folder called <cite>config/</cite>.</p>
<p>And for each file dynaconf will also try to load a <cite>.local.</cite> file, for example, if you have a <cite>settings.toml</cite> after loading it Dynaconf will also try to find a <cite>settings.local.toml</cite> if exists.</p>
<p>Dynaconf will stop searching on the first match for each file and if no file is found it will <strong>fail silently</strong> unless <cite>SILENT_ERRORS_FOR_DYNACONF=false</cite> is exported.</p>
<p>### Illustrative Example</p>
<p>&gt; <strong>New in 2.0.0</strong></p>
<p>If your program has the following structure:</p>
<p><a href="#id14"><span class="problematic" id="id15">``</span></a><a href="#id16"><span class="problematic" id="id17">`</span></a>text
<a href="#id18"><span class="problematic" id="id19">|</span></a>_ myprogram/</p>
<blockquote>
<div><dl class="simple">
<dt><a href="#id20"><span class="problematic" id="id21">|</span></a>_ src/</dt><dd><dl class="simple">
<dt><a href="#id22"><span class="problematic" id="id23">|</span></a>_ app.py</dt><dd><p># from dynaconf import settings
# print(settings.NAME)
# print(settings.PASSWORD)
# print(settings.FOO)</p>
</dd>
</dl>
</dd>
<dt><a href="#id24"><span class="problematic" id="id25">|</span></a>_ config</dt><dd><dl class="simple">
<dt><a href="#id26"><span class="problematic" id="id27">|</span></a>_ settings.toml</dt><dd><p># [default]
# name = “Jon Doe”</p>
</dd>
</dl>
</dd>
<dt><a href="#id28"><span class="problematic" id="id29">|</span></a>_ settings.local.toml</dt><dd><p># [default]
# name = “Oscar Wilde”</p>
</dd>
<dt><a href="#id30"><span class="problematic" id="id31">|</span></a>_ .env</dt><dd><p># DYNACONF_FOO=’BAR’</p>
</dd>
<dt><a href="#id32"><span class="problematic" id="id33">|</span></a>_ .secrets.toml</dt><dd><p># [default]
# password = “Utopi&#64;”</p>
</dd>
</dl>
</div></blockquote>
<p><a href="#id34"><span class="problematic" id="id35">``</span></a><a href="#id36"><span class="problematic" id="id37">`</span></a></p>
<p>And you call it from <cite>myprogram</cite> working dir.</p>
<p><code class="docutils literal notranslate"><span class="pre">`bash</span>
<span class="pre">cd</span> <span class="pre">myprogram</span>
<span class="pre">python</span> <span class="pre">src/app.py</span>
<span class="pre">`</span></code></p>
<p>What happens is:</p>
<p>&gt; NOTE: The behavior explained here is valid only for the above file structure, other arrangements are possible and depending on how folders are organized dynaconf can behave differently.</p>
<ol class="arabic">
<li><p>app.py:1 does <cite>from dynaconf import settings</cite></p>
<blockquote>
<div><ul class="simple">
<li><p>Only the <cite>.env</cite> file will be searched, other settings are lazy evaluated.</p></li>
<li><p><cite>.env</cite> will be searched starting on <cite>myprogram/src/.env</cite></p></li>
<li><p>if not found then <cite>myprogram/src/config/.env</cite></p></li>
<li><p>if not found then <cite>myprogram/.env</cite>  <strong>actually found here so stops searching</strong></p></li>
<li><p>if not found then <cite>myprogram/config/.env</cite></p></li>
<li><p>It will load all values from <cite>.env</cite> to the environment variables and create the instance of <cite>settings</cite></p></li>
</ul>
</div></blockquote>
</li>
<li><p>app.py:2 does the first access to a settings on <cite>print(settings.NAME)</cite></p>
<blockquote>
<div><ul class="simple">
<li><p>Dynaconf will execute the loaders defined in <cite>CORE_LOADERS</cite> and <cite>LOADERS</cite>, it will initialize the <cite>settings</cite> object and start the file search.</p></li>
<li><p><cite>settings.{py|toml|json|ini|yaml}</cite> will be searched on <cite>myprogram/src/</cite></p></li>
<li><p>if not found then <cite>myprogram/src/config</cite></p></li>
<li><p>if not found then <cite>myprogram/</cite></p></li>
<li><p>if not found then <cite>myprogram/config</cite> <strong>settings.toml actually found here so stops searching for toml</strong></p></li>
<li><p>It will load all the values defined in the <cite>settings.toml</cite></p></li>
<li><p>It will continue to look all the other files e.g: settings.json, settings.ini, settings.yaml etc.</p></li>
<li><p>Then</p></li>
<li><p>It will search for <strong>.secrets.{py|toml|json|ini|yaml}</strong> on <cite>myprogram/src/</cite></p></li>
<li><p>if not found then <cite>myprogram/src/config</cite></p></li>
<li><p>if not found then <cite>myprogram/</cite>  <strong>.secrets.toml actually found here so stops searching for toml</strong></p></li>
<li><p>if not found then <cite>myprogram/config</cite></p></li>
<li><p>It will load all the values defined in <cite>.secrets.toml</cite> (if filename is <cite>*.secret.*</cite> values are hidden on logs)</p></li>
<li><p>It will continue to look all the other files e.g: .secrets.json, .secrets.ini, .secrets.yaml etc.</p></li>
<li><p>Then</p></li>
<li><p>It will iterate the list of loaded files containing <cite>[settings.toml, .secrets.toml]</cite> and for each of them it will also try to find a <cite>settings.local.toml</cite> (<strong>found in myprogram/settings.local.toml</strong>) and a <cite>.secrets.local.toml</cite> using the same search tree until it is found or it will skip if not found.</p></li>
<li><p>Then</p></li>
<li><p>It will execute <strong>external loaders</strong> like <cite>Redis</cite> and <cite>Vault</cite> if enabled.</p></li>
<li><p>It will execute <strong>custom loaders</strong> if configured.</p></li>
<li><p>Then finally</p></li>
<li><p>It will read all <strong>environment variables</strong> prefixed with <cite>DYNACONF_</cite> and load its values, in our example it loads <cite>FOO=’BAR’</cite> from <cite>.env</cite> file.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>app.py:3 does second access to a settings on <cite>print(settings.PASSWORD)</cite></p>
<blockquote>
<div><ul class="simple">
<li><p>All the loaders, loaded files, config options and vars are now <strong>cached</strong> no loading has been executed.</p></li>
<li><p>Only if <cite>settings.get_fresh(‘PASSWORD’)</cite> is used, dynaconf will force a re-load of everything to ensure the fresh value.</p></li>
<li><p>Also if <cite>settings.using_env|from_env</cite> or <cite>ENV_FOR_DYNACONF</cite> switched, e.g: from <cite>[development]</cite> to <cite>[staging]</cite>, then re-load happens.</p></li>
<li><p>It is also possible to explicitly force a <cite>load</cite> or <cite>reload</cite>.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Complete program output is:</p></li>
</ol>
<p><code class="docutils literal notranslate"><span class="pre">`bash</span>
<span class="pre">Oscar</span> <span class="pre">Wilde</span>
<span class="pre">Utopi&#64;</span>
<span class="pre">BAR</span>
<span class="pre">`</span></code></p>
<p>## Loading order</p>
<p>Dynaconf loads file in a overriding cascade loading order using the predefined order:</p>
<ol class="arabic simple">
<li><p>First the environment variables (and <cite>.env</cite> file) to read for [configuration](configuration.html) options</p></li>
<li><p>Then the paths provided in <cite>PRELOAD_FOR_DYNACONF</cite> using all enabled loaders.</p></li>
<li><dl class="simple">
<dt>Then the files defined in <cite>SETTINGS_FILE_FOR_DYNACONF</cite> using all enabled loaders.</dt><dd><ul class="simple">
<li><p>Files containing <cite>.local.</cite> in its name will be loaded at the end. e.g: <cite>settings.local.yaml</cite></p></li>
</ul>
</dd>
</dl>
</li>
<li><p>Then contents of <cite>SECRETS_FOR_DYNACONF</cite> envvar filename if defined (useful for jenkins and other CI)</p></li>
<li><dl class="simple">
<dt>Then the loaders defined in <cite>LOADERS_FOR_DYNACONF</cite></dt><dd><ul class="simple">
<li><p>Redis if enabled by <cite>REDIS_FOR_DYNACONF=1</cite></p></li>
<li><p>Vault if enabled by <cite>Vault_FOR_DYNACONF=1</cite></p></li>
<li><p>Custom loaders if any added</p></li>
<li><p>Environment variables loader will be the last always</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>If there is any <cite>DYNACONF_INCLUDE</cite> key found or <cite>INCLUDES_FOR_DYNACONF</cite> env vars this will be loaded.</p></li>
</ol>
<p>The order can be changed by overriding the <cite>SETTINGS_FILE_FOR_DYNACONF</cite> the <cite>CORE_LOADERS_FOR_DYNACONF</cite> and <cite>LOADERS_FOR_DYNACONF</cite> variables.</p>
<p>&gt; <strong>NOTE</strong>: Dynaconf works in an <strong>layered override</strong> mode based on the above order, so if you have multiple file formats with conflicting keys defined, the precedence will be based on the loading order.
&gt; If you dont want to have values like <cite>lists</cite> and <cite>dicts</cite> overwritten take a look on how to [merge existing values](usage.html#merging-existing-values)</p>
<p>## Local configuration files and merging to existing data</p>
<p>&gt; New in <strong>2.2.0</strong></p>
<p>This feature is useful for maintaining a shared set of config files for a team, while still allowing for local configuration.</p>
<p>Any file matched by the glob <cite>*.local.*</cite> will be read at the end of file loading order. So it is possible to have local settings files that are for example not committed to the version controlled repository. (e:g add <cite>**/*.local*</cite> to your <cite>.gitignore</cite>)</p>
<p>So if you have <cite>settings.toml</cite> Dynaconf will load it and after all will also try to load a file named <cite>settings.local.toml</cite> if it does exist. And the same applies to all the other supported extensions <cite>settings.local.{py,json,yaml,toml,ini,cfg}</cite></p>
<p>Example:</p>
<p><a href="#id38"><span class="problematic" id="id39">``</span></a><a href="#id40"><span class="problematic" id="id41">`</span></a>ini
# settings.toml        # &lt;– 1st loaded
[default]
colors = [“green”, “blue”]
parameters = {enabled=true, number=42}</p>
<p># .secrets.toml        # &lt;– 2nd loaded  (overrides previous existing vars)
[default]
password = 1234</p>
<p># settings.local.toml  # &lt;– 3rd loaded  (overrides previous existing vars)
[default]
colors = [“pink”]
parameters = {enabled=false}
password = 9999
<a href="#id42"><span class="problematic" id="id43">``</span></a><a href="#id44"><span class="problematic" id="id45">`</span></a></p>
<p>So with above the values will be:</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">settings.COLORS</span> <span class="pre">==</span> <span class="pre">[&quot;pink&quot;]</span>
<span class="pre">settings.PARAMETERS</span> <span class="pre">==</span> <span class="pre">{&quot;enabled&quot;:</span> <span class="pre">False}</span>
<span class="pre">settings.PASSWORD</span> <span class="pre">==</span> <span class="pre">9999</span>
<span class="pre">`</span></code></p>
<p>For each loaded file dynaconf will <cite>override</cite> previous existing keys so if you want to <cite>append</cite> new values to existing variables you can use 3 strategies.</p>
<p>### Mark the local file to be entirely merged</p>
<p>&gt; New in <strong>2.2.0</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">`ini</span>
<span class="pre">#</span> <span class="pre">settings.local.toml</span>
<span class="pre">dynaconf_merge</span> <span class="pre">=</span> <span class="pre">true</span>
<span class="pre">[default]</span>
<span class="pre">colors</span> <span class="pre">=</span> <span class="pre">[&quot;pink&quot;]</span>
<span class="pre">parameters</span> <span class="pre">=</span> <span class="pre">{enabled=false}</span>
<span class="pre">`</span></code></p>
<p>By adding <cite>dynaconf_merge</cite> to the top root of the file mark entire file to be merged.</p>
<p>And then the values will be updated in to existing data structures.</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">settings.COLORS</span> <span class="pre">==</span> <span class="pre">[&quot;pink&quot;,</span> <span class="pre">&quot;green&quot;,</span> <span class="pre">&quot;blue&quot;]</span>
<span class="pre">settings.PARAMETERS</span> <span class="pre">==</span> <span class="pre">{&quot;enabled&quot;:</span> <span class="pre">False,</span> <span class="pre">&quot;number&quot;:</span> <span class="pre">42}</span>
<span class="pre">settings.PASSWORD</span> <span class="pre">==</span> <span class="pre">9999</span>
<span class="pre">`</span></code></p>
<p>You can also mark a single <cite>env</cite> like <cite>[development]</cite> to be merged.</p>
<p><code class="docutils literal notranslate"><span class="pre">`ini</span>
<span class="pre">#</span> <span class="pre">settings.local.toml</span>
<span class="pre">[development]</span>
<span class="pre">dynaconf_merge</span> <span class="pre">=</span> <span class="pre">true</span>
<span class="pre">colors</span> <span class="pre">=</span> <span class="pre">[&quot;pink&quot;]</span>
<span class="pre">parameters</span> <span class="pre">=</span> <span class="pre">{enabled=false}</span>
<span class="pre">`</span></code></p>
<p>### dynaconf merge token</p>
<p><code class="docutils literal notranslate"><span class="pre">`ini</span>
<span class="pre">#</span> <span class="pre">settings.local.toml</span>
<span class="pre">[default]</span>
<span class="pre">colors</span> <span class="pre">=</span> <span class="pre">[&quot;pink&quot;,</span> <span class="pre">&quot;dynaconf_merge&quot;]</span>
<span class="pre">parameters</span> <span class="pre">=</span> <span class="pre">{enabled=false,</span> <span class="pre">dynaconf_merge=true}</span>
<span class="pre">`</span></code></p>
<p>By adding <cite>dynaconf_merge</cite> to a <cite>list</cite> or <cite>dict</cite> marks it as a merge candidate.</p>
<p>And then the values will be updated in to existing data structures.</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">settings.COLORS</span> <span class="pre">==</span> <span class="pre">[&quot;pink&quot;,</span> <span class="pre">&quot;green&quot;,</span> <span class="pre">&quot;blue&quot;]</span>
<span class="pre">settings.PARAMETERS</span> <span class="pre">==</span> <span class="pre">{&quot;enabled&quot;:</span> <span class="pre">False,</span> <span class="pre">&quot;number&quot;:</span> <span class="pre">42}</span>
<span class="pre">settings.PASSWORD</span> <span class="pre">==</span> <span class="pre">9999</span>
<span class="pre">`</span></code></p>
<p>&gt; New in <strong>2.2.0</strong></p>
<p>And it also works having <cite>dynaconf_merge</cite> as dict keys holding the value to be merged.</p>
<p><a href="#id46"><span class="problematic" id="id47">``</span></a><a href="#id48"><span class="problematic" id="id49">`</span></a>ini
# settings.local.toml
[default.colors]
dynaconf_merge = [“pink”]  # &lt;– value [“pink”] will be merged in to existing colors</p>
<p>[default.parameters]
dynaconf_merge = {enabled=false}
<a href="#id50"><span class="problematic" id="id51">``</span></a><a href="#id52"><span class="problematic" id="id53">`</span></a></p>
<p>### Dunder merging for nested structures</p>
<p>For nested structures the recommendation is to use dunder merging because it it easier to read and also it has no limitations in terms of nesting levels.</p>
<p><code class="docutils literal notranslate"><span class="pre">`ini</span>
<span class="pre">#</span> <span class="pre">settings.local.yaml</span>
<span class="pre">[default]</span>
<span class="pre">parameters__enabled</span> <span class="pre">=</span> <span class="pre">false</span>
<span class="pre">`</span></code></p>
<p>The use of <cite>__</cite> to denote nested level will ensure the key is merged with existing values read more in [merging existing values](#merging-existing-values).</p>
<p>### Global merge</p>
<p><code class="docutils literal notranslate"><span class="pre">`bash</span>
<span class="pre">export</span> <span class="pre">MERGE_ENABLED_FOR_DYNACONF=true</span>
<span class="pre">`</span></code></p>
<p>or put it in your <cite>.env</cite> file then Dynaconf will automatically merge all existing variables.</p>
<p>&gt; <strong>BEWARE</strong>: Using <cite>MERGE_ENABLED_FOR_DYNACONF</cite> can lead to unexpected results because you do not have granular control of what is being merged or overwritten so the recommendation is to use other options.</p>
<p>## Settings File Formats</p>
<p>The recommended file format is <strong>TOML</strong> but you can choose to use any of <strong>.{py|toml|json|ini|yaml}</strong>.</p>
<p>The file must be a series of sections, at least one for <strong>[default]</strong>, optionally one for each <strong>[environment]</strong>, and an optional <strong>[global]</strong> section. Each section contains <strong>key-value</strong> pairs corresponding to configuration parameters for that <strong>[environment]</strong>. If a configuration parameter is missing, the value from <strong>[default]</strong> is used. The following is a complete <cite>settings.toml</cite> file, where every standard configuration parameter is specified within the <strong>[default]</strong> section:</p>
<p>&gt; <strong>NOTE</strong>: if the file format choosen is <cite>.py</cite> as it does not support sections you can create multiple files like <cite>settings.py</cite> for [default], <cite>development_settings.py</cite>, <cite>production_settings.py</cite> and <cite>global_settings.py</cite>. <strong>ATTENTION</strong>: using <cite>.py</cite> is not recommended for configuration - prefer to use static files like <strong>TOML</strong>!</p>
<p><a href="#id54"><span class="problematic" id="id55">``</span></a><a href="#id56"><span class="problematic" id="id57">`</span></a>ini
[default]
username = “admin”
port = 5000
host = “localhost”
message = “default message”
value = “default value”</p>
<p>[development]
username = “devuser”</p>
<p>[staging]
host = “staging.server.com”</p>
<p>[testing]
host = “testing.server.com”</p>
<p>[production]
host = “server.com”</p>
<p>[awesomeenv]
value = “this value is set for custom [awesomeenv]”</p>
<p>[global]
message = “This value overrides message of default and other envs”
<a href="#id58"><span class="problematic" id="id59">``</span></a><a href="#id60"><span class="problematic" id="id61">`</span></a></p>
<p>The <strong>[global]</strong> pseudo-environment can be used to set and/or override configuration parameters globally. A parameter defined in a <strong>[global]</strong> section sets, or overrides if already present, that parameter in every environment.</p>
<p>&gt; IMPORTANT: the environments and pseudo envs such as <cite>[global], [‘default’]</cite> affects only the current file, it means that a value in <cite>[global]</cite> will override values defined only on that file or previous loaded files, if in another file the value is reloaded then the global values is overwritten. Dynaconf supports multiple file formats but the recommendation is not to mix them, choose a format and stick with it.</p>
<p>For example, given the following <cite>settings.toml</cite> file, the value of address will be <strong>“1.2.3.4”</strong> in every environment:</p>
<p><a href="#id62"><span class="problematic" id="id63">``</span></a><a href="#id64"><span class="problematic" id="id65">`</span></a>cfg
[global]
address = “1.2.3.4”</p>
<p>[development]
address = “localhost”</p>
<p>[production]
address = “0.0.0.0”
<a href="#id66"><span class="problematic" id="id67">``</span></a><a href="#id68"><span class="problematic" id="id69">`</span></a></p>
<p>&gt; <strong>NOTE</strong>: The <strong>[env]</strong> name and first level variables are case insensitive as internally dynaconf will always use upper case, that means <strong>[development]</strong> and <strong>[DEVELOPMENT]</strong> are equivalent and <strong>address</strong> and <strong>ADDRESS</strong> are also equivalent. <strong>But the recommendation is to `always use lower case in files` and `always use upper case in env vars and .py files`</strong> (This rule does not apply for inner data structures as dictionaries and arrays).</p>
<p>## Supported file formats</p>
<p>By default <strong>toml</strong> is the recommended format to store your configuration, however you can switch to a different supported format.</p>
<p><a href="#id70"><span class="problematic" id="id71">``</span></a><a href="#id72"><span class="problematic" id="id73">`</span></a>bash
# If you wish to include support for more sources
pip3 install dynaconf[yaml|ini|redis|vault]</p>
<p># for a complete installation
pip3 install dynaconf[all]
<a href="#id74"><span class="problematic" id="id75">``</span></a><a href="#id76"><span class="problematic" id="id77">`</span></a></p>
<p>Once the support is installed no extra configuration is needed to load data from those files.</p>
<p>If you need a different file format take a look on how to extend dynaconf writing a [custom loader](extend.html)</p>
<p>## Additional secrets file (for CI, jenkins etc.)</p>
<p>It is common to have an extra <cite>secrets</cite> file that is available only when running on specific CI environment like <cite>Jenkins</cite>, usually there will be an environment variable pointing to the file.</p>
<p>On Jenkins it is done on job settings by exporting the <cite>secrets</cite> information.</p>
<p>Dynaconf can handle this via <cite>SECRETS_FOR_DYNACONF</cite> environment variable.</p>
<p>ex:</p>
<p><code class="docutils literal notranslate"><span class="pre">`bash</span>
<span class="pre">export</span> <span class="pre">SECRETS_FOR_DYNACONF=/path/to/settings.toml{json|py|ini|yaml}</span>
<span class="pre">`</span></code></p>
<p>If that variable exists in your environment then Dynaconf will also load it.</p>
<p>## Including files inside files</p>
<p>Sometimes you have multiple fragments of settings in different files, dynaconf allow easy merging of those files via <cite>dynaconf_include</cite>.</p>
<p>Example:</p>
<p><cite>plugin1.toml</cite></p>
<p><code class="docutils literal notranslate"><span class="pre">`cfg</span>
<span class="pre">[development]</span>
<span class="pre">plugin_specific_variable</span> <span class="pre">=</span> <span class="pre">'value</span> <span class="pre">for</span> <span class="pre">development'</span>
<span class="pre">`</span></code></p>
<p>and even mixing different formats:
<cite>plugin2.yaml</cite></p>
<p><a href="#id78"><span class="problematic" id="id79">``</span></a><a href="#id80"><span class="problematic" id="id81">`</span></a>yaml
production:</p>
<blockquote>
<div><p>plugin_specific_variable: ‘value for production’</p>
</div></blockquote>
<p><a href="#id82"><span class="problematic" id="id83">``</span></a><a href="#id84"><span class="problematic" id="id85">`</span></a></p>
<p>Then it can be merged on main <cite>settings.toml</cite> file via <cite>dynaconf_include</cite></p>
<p><cite>settings.toml</cite></p>
<p><code class="docutils literal notranslate"><span class="pre">`cfg</span>
<span class="pre">[default]</span>
<span class="pre">dynaconf_include</span> <span class="pre">=</span> <span class="pre">[&quot;plugin1.toml&quot;,</span> <span class="pre">&quot;plugin2.yaml&quot;]</span>
<span class="pre">DEBUG</span> <span class="pre">=</span> <span class="pre">false</span>
<span class="pre">SERVER</span> <span class="pre">=</span> <span class="pre">&quot;base.example.com&quot;</span>
<span class="pre">PORT</span> <span class="pre">=</span> <span class="pre">6666</span>
<span class="pre">`</span></code></p>
<dl>
<dt>A settings file can include a <cite>dynaconf_include</cite> stanza, whose exact</dt><dd><p>syntax will depend on the type of settings file (json, yaml, toml, etc)
being used:</p>
<p><code class="docutils literal notranslate"><span class="pre">`cfg</span>
<span class="pre">[default]</span>
<span class="pre">dynaconf_include</span> <span class="pre">=</span> <span class="pre">[&quot;/absolute/path/to/plugin1.toml&quot;,</span> <span class="pre">&quot;relative/path/to/plugin2.toml&quot;]</span>
<span class="pre">DEBUG</span> <span class="pre">=</span> <span class="pre">false</span>
<span class="pre">SERVER</span> <span class="pre">=</span> <span class="pre">&quot;www.example.com&quot;</span>
<span class="pre">`</span></code></p>
<p>When loaded, the files located at the (relative or absolute) paths in
the <cite>dynaconf_include</cite> key will be parsed, in order, and override any
base settings that may exist in your current configuration.</p>
<p>The paths can be relative to the base <cite>settings.(toml|yaml|json|ini|py)</cite>
file, or can be absolute paths.</p>
<p>The idea here is that plugins or extensions for whatever framework or
architecture you are using can provide their own configuration values
when necessary.</p>
<p>It is also possible to specify glob-based patterns:</p>
<p><code class="docutils literal notranslate"><span class="pre">`cfg</span>
<span class="pre">[default]</span>
<span class="pre">dynaconf_include</span> <span class="pre">=</span> <span class="pre">[&quot;configurations/*.toml&quot;]</span>
<span class="pre">DEBUG</span> <span class="pre">=</span> <span class="pre">false</span>
<span class="pre">SERVER</span> <span class="pre">=</span> <span class="pre">&quot;www.example.com&quot;</span>
<span class="pre">`</span></code></p>
<p>Currently, only a single level of includes is permitted to keep things
simple and straightforward.</p>
</dd>
</dl>
<p>### Including via environment variable</p>
<p>It is also possible to setup includes using environment variable.</p>
<p><code class="docutils literal notranslate"><span class="pre">`bash</span>
<span class="pre">#</span> <span class="pre">A</span> <span class="pre">glob</span> <span class="pre">pattern</span>
<span class="pre">export</span> <span class="pre">INCLUDES_FOR_DYNACONF='/etc/myprogram/conf.d/*.toml'</span>
<span class="pre">#</span> <span class="pre">a</span> <span class="pre">single</span> <span class="pre">path</span>
<span class="pre">export</span> <span class="pre">INCLUDES_FOR_DYNACONF='/path/to/file.yaml'</span>
<span class="pre">#</span> <span class="pre">multiple</span> <span class="pre">files</span>
<span class="pre">export</span> <span class="pre">INCLUDES_FOR_DYNACONF='/path/to/file.yaml;/other/path/to/file.toml'</span>
<span class="pre">`</span></code></p>
<p>## Programmatically loading a settings file</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">from</span> <span class="pre">dynaconf</span> <span class="pre">import</span> <span class="pre">settings</span>
<span class="pre">settings.load_file(path=&quot;/path/to/file.toml&quot;)</span>&#160; <span class="pre">#</span> <span class="pre">list</span> <span class="pre">or</span> <span class="pre">`;/,`</span> <span class="pre">separated</span> <span class="pre">allowed</span>
<span class="pre">`</span></code></p>
<p>&gt; <strong>NOTE</strong>: programmatically loaded file is not persisted, once <cite>env</cite> is changed via <cite>setenv|ugin_env</cite>, or a <cite>reload</cite> or <cite>configure</cite> is invoked it will be cleaned, to persist it needs to go to <cite>INCLUDES_FOR_DYNACONF</cite> variable or you need to load it programmatically again.</p>
<p>## Template substitutions</p>
<p>Dynaconf has 2 tokens to enable string substitutions <cite>&#64;format</cite> and <cite>&#64;jinja</cite>.</p>
<p>### &#64;format token</p>
<p>Dynaconf allows template substitutions for strings values, by using the <cite>&#64;format</cite> token prefix and including placeholders accepted by Python’s <cite>str.format</cite> method Dynaconf will call
it lazily upon access time.</p>
<p>The call will be like:</p>
<p><code class="docutils literal notranslate"><span class="pre">`py</span>
<span class="pre">&quot;&lt;YOURVALUE&gt;&quot;.format(env=os.environ,</span> <span class="pre">this=dynaconf.settings)</span>
<span class="pre">`</span></code></p>
<p>So in your string you can refer to environment variables via <cite>env</cite> object, and also to variables defined int the settings object itself via <cite>this</cite> reference. It is lazily evaluated on access it will use the final value for a settings regardless the order of load.</p>
<p>Example:</p>
<p><code class="docutils literal notranslate"><span class="pre">`bash</span>
<span class="pre">export</span> <span class="pre">PROGRAM_NAME=calculator</span>
<span class="pre">`</span></code></p>
<p>settings.toml</p>
<p><a href="#id86"><span class="problematic" id="id87">``</span></a><a href="#id88"><span class="problematic" id="id89">`</span></a>toml
[default]
DB_NAME = “mydb.db”</p>
<p>[development]
DB_PATH = “&#64;format {env[HOME]}/{this.current_env}/{env[PROGRAM_NAME]}/{this.DB_NAME}”
<a href="#id90"><span class="problematic" id="id91">``</span></a><a href="#id92"><span class="problematic" id="id93">`</span></a></p>
<ul class="simple">
<li><p><cite>{env[HOME]}</cite> is the same as <cite>os.environ[“HOME”]</cite> or <cite>$HOME</cite> in the shell.</p></li>
<li><p><cite>{this.current_env}</cite> is the same as <cite>settings.current_env</cite></p></li>
<li><p><cite>{env[PROGRAM_NAME]}</cite> is the same as <cite>os.environ[“PROGRAM_NAME”]</cite> or <cite>$PROGRAM_NAME</cite> in the shell.</p></li>
<li><p><cite>{this.DB_NAME}</cite> is the same as <cite>settins.DB_NAME</cite> or <cite>settings[“DB_NAME”]</cite></p></li>
</ul>
<p>so in your <cite>program</cite></p>
<p><a href="#id94"><span class="problematic" id="id95">``</span></a><a href="#id96"><span class="problematic" id="id97">`</span></a>py
from dynaconf import settings</p>
<p>settings.DB_PATH == ‘~/DEVELOPMENT/calculator/mydb.db’
<a href="#id98"><span class="problematic" id="id99">``</span></a><a href="#id100"><span class="problematic" id="id101">`</span></a></p>
<p>### &#64;jinja token</p>
<p>If <cite>jinja2</cite> package is installed then dynaconf will also allow the use jinja to render string values.</p>
<p>Example:</p>
<p><code class="docutils literal notranslate"><span class="pre">`bash</span>
<span class="pre">export</span> <span class="pre">PROGRAM_NAME=calculator</span>
<span class="pre">`</span></code></p>
<p>settings.toml</p>
<p><a href="#id102"><span class="problematic" id="id103">``</span></a><a href="#id104"><span class="problematic" id="id105">`</span></a>toml
[default]
DB_NAME = “mydb.db”</p>
<p>[development]
DB_PATH = “&#64;jinja {{env.HOME}}/{{this.current_env | lower}}/{{env[‘PROGRAM_NAME’]}}/{{this.DB_NAME}}”
<a href="#id106"><span class="problematic" id="id107">``</span></a><a href="#id108"><span class="problematic" id="id109">`</span></a></p>
<p>so in your <cite>program</cite></p>
<p><a href="#id110"><span class="problematic" id="id111">``</span></a><a href="#id112"><span class="problematic" id="id113">`</span></a>py
from dynaconf import settings</p>
<p>settings.DB_PATH == ‘~/development/calculator/mydb.db’
<a href="#id114"><span class="problematic" id="id115">``</span></a><a href="#id116"><span class="problematic" id="id117">`</span></a></p>
<p>The main difference is that Jinja allows some Python expressions to be avaluated such as <cite>{% for, if, while %}</cite> and also supports calling methods and has lots of filters like <cite>| lower</cite>.</p>
<p>Jinja supports its built-in filters listed in [Builtin Filters Page](<a class="reference external" href="http://jinja.palletsprojects.com/en/master/templates/#builtin-filters">http://jinja.palletsprojects.com/en/master/templates/#builtin-filters</a>) and Dynaconf includes aditional filters for <cite>os.path</cite> module: <cite>abspath</cite>. <cite>realpath</cite>, <cite>relpath</cite>, <cite>basename</cite> and <cite>dirname</cite> and usage is like: <cite>VALUE = “&#64;jinja {{this.FOO | abspath}}”</cite></p>
<p>## Merging existing data structures</p>
<p>If your settings has existing variables of types <cite>list</cite> ot <cite>dict</cite> and you want to <cite>merge</cite> instead of <cite>override</cite> then
the <cite>dynaconf_merge</cite> and <cite>dynaconf_merge_unique</cite> stanzas can mark that variable as a candidate for merging.</p>
<p>For <strong>dict</strong> value:</p>
<p>Your main settings file (e.g <cite>settings.toml</cite>) has an existing <cite>DATABASE</cite> dict setting on <cite>[default]</cite> env.</p>
<p>Now you want to contribute to the same <cite>DATABASE</cite> key by adding new keys, so you can use <cite>dynaconf_merge</cite> at the end of your dict:</p>
<p>In specific <cite>[envs]</cite></p>
<p><a href="#id118"><span class="problematic" id="id119">``</span></a><a href="#id120"><span class="problematic" id="id121">`</span></a>cfg
[default]
database = {host=”server.com”, user=”default”}</p>
<p>[development]
database = {user=”dev_user”, dynaconf_merge=true}</p>
<p>[production]
database = {user=”prod_user”, dynaconf_merge=true}
<a href="#id122"><span class="problematic" id="id123">``</span></a><a href="#id124"><span class="problematic" id="id125">`</span></a></p>
<p>also allowed the alternative short format</p>
<p><a href="#id126"><span class="problematic" id="id127">``</span></a><a href="#id128"><span class="problematic" id="id129">`</span></a>cfg
[default]
database = {host=”server.com”, user=”default”}</p>
<p>[development.database]
dynaconf_merge = {user=”dev_user”}</p>
<p>[production.database]
dynaconf_merge = {user=”prod_user”}
<a href="#id130"><span class="problematic" id="id131">``</span></a><a href="#id132"><span class="problematic" id="id133">`</span></a></p>
<p>In an environment variable:</p>
<p>Using <cite>&#64;merge</cite> mark</p>
<p><code class="docutils literal notranslate"><span class="pre">`bash</span>
<span class="pre">#</span> <span class="pre">Toml</span> <span class="pre">formatted</span> <span class="pre">envvar</span>
<span class="pre">export</span> <span class="pre">DYNACONF_DATABASE='&#64;merge</span> <span class="pre">{password=1234}'</span>
<span class="pre">`</span></code></p>
<p>or <cite>&#64;merge</cite> mark short format</p>
<p><code class="docutils literal notranslate"><span class="pre">`bash</span>
<span class="pre">#</span> <span class="pre">Toml</span> <span class="pre">formatted</span> <span class="pre">envvar</span>
<span class="pre">export</span> <span class="pre">DYNACONF_DATABASE='&#64;merge</span> <span class="pre">password=1234'</span>
<span class="pre">`</span></code></p>
<p>It is also possible to use nested <cite>dunder</cite> traversal like:</p>
<p><code class="docutils literal notranslate"><span class="pre">`bash</span>
<span class="pre">export</span> <span class="pre">DYNACONF_DATABASE__password=1234</span>
<span class="pre">export</span> <span class="pre">DYNACONF_DATABASE__user=admin</span>
<span class="pre">export</span> <span class="pre">DYNACONF_DATABASE__ARGS__timeout=30</span>
<span class="pre">export</span> <span class="pre">DYNACONF_DATABASE__ARGS__retries=5</span>
<span class="pre">`</span></code></p>
<p>Each <cite>__</cite> is parsed as a level traversing thought dict keys. read more in [environment variables](environment_variables.html#nested-keys-in-dictionaries-via-environment-variables)</p>
<p>So the above will result in</p>
<p><code class="docutils literal notranslate"><span class="pre">`py</span>
<span class="pre">DATABASE</span> <span class="pre">=</span> <span class="pre">{'password':</span> <span class="pre">1234,</span> <span class="pre">'user':</span> <span class="pre">'admin',</span> <span class="pre">'ARGS':</span> <span class="pre">{'timeout':</span> <span class="pre">30,</span> <span class="pre">'retries':</span> <span class="pre">5}}</span>
<span class="pre">`</span></code></p>
<p>&gt; <strong>IMPORTANT</strong> lower case keys are respected only on <a href="#id134"><span class="problematic" id="id135">*</span></a>nix systems, unfortunately Windows environment variables are case insensitive and Python reads it as all upper cases, that means that if you are running on Windows the dictionary can have only upper case keys.</p>
<p>You can also export a toml dictionary.</p>
<p><code class="docutils literal notranslate"><span class="pre">`bash</span>
<span class="pre">#</span> <span class="pre">Toml</span> <span class="pre">formatted</span> <span class="pre">envvar</span>
<span class="pre">export</span> <span class="pre">DYNACONF_DATABASE='{password=1234,</span> <span class="pre">dynaconf_merge=true}'</span>
<span class="pre">`</span></code></p>
<p>Or in an additional file (e.g <cite>settings.yaml, .secrets.yaml, etc</cite>) by using <cite>dynaconf_merge</cite> token:</p>
<p><a href="#id136"><span class="problematic" id="id137">``</span></a><a href="#id138"><span class="problematic" id="id139">`</span></a>yaml
default:</p>
<blockquote>
<div><dl class="simple">
<dt>database:</dt><dd><p>password: 1234
dynaconf_merge: true</p>
</dd>
</dl>
</div></blockquote>
<p><a href="#id140"><span class="problematic" id="id141">``</span></a><a href="#id142"><span class="problematic" id="id143">`</span></a></p>
<p>or</p>
<p><a href="#id144"><span class="problematic" id="id145">``</span></a><a href="#id146"><span class="problematic" id="id147">`</span></a>yaml
default:</p>
<blockquote>
<div><dl class="simple">
<dt>database:</dt><dd><dl class="simple">
<dt>dynaconf_merge:</dt><dd><p>password: 1234</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p><a href="#id148"><span class="problematic" id="id149">``</span></a><a href="#id150"><span class="problematic" id="id151">`</span></a></p>
<p>The <cite>dynaconf_merge</cite> token will mark that object to be merged with existing values (of course <cite>dynaconf_merge</cite> key will not be added to the final settings it is just a mark)</p>
<p>The end result will be on <cite>[development]</cite> env:</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">settings.DATABASE</span> <span class="pre">==</span> <span class="pre">{'host':</span> <span class="pre">'server.com',</span> <span class="pre">'user':</span> <span class="pre">'dev_user',</span> <span class="pre">'password':</span> <span class="pre">1234}</span>
<span class="pre">`</span></code></p>
<p>The same can be applied to <strong>lists</strong>:</p>
<p><cite>settings.toml</cite></p>
<p><a href="#id152"><span class="problematic" id="id153">``</span></a><a href="#id154"><span class="problematic" id="id155">`</span></a>cfg
[default]
plugins = [“core”]</p>
<p>[development]
plugins = [“debug_toolbar”, “dynaconf_merge”]
<a href="#id156"><span class="problematic" id="id157">``</span></a><a href="#id158"><span class="problematic" id="id159">`</span></a></p>
<p>or</p>
<p><a href="#id160"><span class="problematic" id="id161">``</span></a><a href="#id162"><span class="problematic" id="id163">`</span></a>cfg
[default]
plugins = [“core”]</p>
<p>[development.plugins]
dynaconf_merge = [“debug_toolbar”]
<a href="#id164"><span class="problematic" id="id165">``</span></a><a href="#id166"><span class="problematic" id="id167">`</span></a></p>
<p>And in environment variable</p>
<p>using <cite>&#64;merge</cite> token</p>
<p><code class="docutils literal notranslate"><span class="pre">`bash</span>
<span class="pre">export</span> <span class="pre">DYNACONF_PLUGINS='&#64;merge</span> <span class="pre">[&quot;ci_plugin&quot;]'</span>
<span class="pre">`</span></code></p>
<p>or short version</p>
<p><code class="docutils literal notranslate"><span class="pre">`bash</span>
<span class="pre">export</span> <span class="pre">DYNACONF_PLUGINS='&#64;merge</span> <span class="pre">ci_plugin'</span>
<span class="pre">`</span></code></p>
<p>comma separated values also supported:</p>
<p><code class="docutils literal notranslate"><span class="pre">`bash</span>
<span class="pre">export</span> <span class="pre">DYNACONF_PLUGINS='&#64;merge</span> <span class="pre">ci_plugin,other_plugin'</span>
<span class="pre">`</span></code></p>
<p>or explicitly</p>
<p><code class="docutils literal notranslate"><span class="pre">`bash</span>
<span class="pre">export</span> <span class="pre">DYNACONF_PLUGINS='[&quot;ci_plugin&quot;,</span> <span class="pre">&quot;dynaconf_merge&quot;]'</span>
<span class="pre">`</span></code></p>
<p>Then the end result on <cite>[development]</cite> is:</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">settings.PLUGINS</span> <span class="pre">==</span> <span class="pre">[&quot;ci_plugin&quot;,</span> <span class="pre">&quot;debug_toolbar&quot;,</span> <span class="pre">&quot;core&quot;]</span>
<span class="pre">`</span></code></p>
<p>If your value is a dictionary:</p>
<p><a href="#id168"><span class="problematic" id="id169">``</span></a><a href="#id170"><span class="problematic" id="id171">`</span></a>bash
export DYNACONF_DATA=”&#64;merge {foo=’bar’}”</p>
<p># or the short</p>
<p>export DYNACONF_DATA=”&#64;merge foo=bar”
<a href="#id172"><span class="problematic" id="id173">``</span></a><a href="#id174"><span class="problematic" id="id175">`</span></a></p>
<p>### Avoiding duplications on lists</p>
<p>The <cite>dynaconf_merge_unique</cite> is the token for when you want to avoid duplications in a list.</p>
<p>Example:</p>
<p><a href="#id176"><span class="problematic" id="id177">``</span></a><a href="#id178"><span class="problematic" id="id179">`</span></a>cfg
[default]
scripts = [‘install.sh’, ‘deploy.sh’]</p>
<p>[development]
scripts = [‘dev.sh’, ‘test.sh’, ‘deploy.sh’, ‘dynaconf_merge_unique’]
<a href="#id180"><span class="problematic" id="id181">``</span></a><a href="#id182"><span class="problematic" id="id183">`</span></a></p>
<p><code class="docutils literal notranslate"><span class="pre">`bash</span>
<span class="pre">export</span> <span class="pre">DYNACONF_SCRIPTS='[&quot;deploy.sh&quot;,</span> <span class="pre">&quot;run.sh&quot;,</span> <span class="pre">&quot;dynaconf_merge_unique&quot;]'</span>
<span class="pre">`</span></code></p>
<p>The end result for <cite>[development]</cite> will be:</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">settings.SCRIPTS</span> <span class="pre">==</span> <span class="pre">['install.sh',</span> <span class="pre">'dev.sh',</span> <span class="pre">'test.sh',</span> <span class="pre">'deploy.sh',</span> <span class="pre">'run.sh']</span>
<span class="pre">`</span></code></p>
<p>&gt; Note that <cite>deploy.sh</cite> is set 3 times but it is not repeated in the final settings.</p>
<p>### Known caveats</p>
<p>The <strong>dynaconf_merge</strong> and <strong>&#64;merge</strong> functionalities works only for the first level keys, it will not merge subdicts or nested lists (yet).</p>
<p>For deeper nested objects use [dunder merge](environment_variables.html#nested-keys-in-dictionaries-via-environment-variables).</p>
<p>### Global merge</p>
<p><code class="docutils literal notranslate"><span class="pre">`bash</span>
<span class="pre">export</span> <span class="pre">MERGE_ENABLED_FOR_DYNACONF=true</span>
<span class="pre">`</span></code></p>
<p>or put it in your <cite>.env</cite> file then Dynaconf will automatically merge all existing variables.</p>
<p>&gt; <strong>BEWARE</strong>: Using <cite>MERGE_ENABLED_FOR_DYNACONF</cite> can lead to unexpected results because you do not have granular control of what is being merged or overwritten so the recommendation is to use other options.</p>
<p>## More examples</p>
<p>Take a look at the [example](<a class="reference external" href="https://github.com/rochacbruno/dynaconf/tree/master/example">https://github.com/rochacbruno/dynaconf/tree/master/example</a>) folder to see some examples of use with different file formats and features.</p>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../index.html">
    <img class="logo" src="../_static/logo.svg" alt="Logo"/>
    
    <h1 class="logo logo-name">dynaconf</h1>
    
  </a>
</p>



<p class="blurb">Layered configuration system for Python applications</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=rochacbruno&repo=dynaconf&type=star&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">)</a></li>
<li class="toctree-l1"><a class="reference internal" href="environment_variables.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="environment_variables.html#id24">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="environment_variables.html#id31">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="environment_variables.html#id36">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="environment_variables.html#id41">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="environment_variables.html#id46">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="environment_variables.html#id51">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="accessing_values.html">)</a></li>
<li class="toctree-l1"><a class="reference internal" href="external_storages.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="external_storages.html#id6">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="configuration.html">)</a></li>
<li class="toctree-l1"><a class="reference internal" href="advanced_usage.html">)</a></li>
<li class="toctree-l1"><a class="reference internal" href="flask.html">)</a></li>
<li class="toctree-l1"><a class="reference internal" href="flask.html#id16">]</a></li>
<li class="toctree-l1"><a class="reference internal" href="flask.html#id29">]</a></li>
<li class="toctree-l1"><a class="reference internal" href="django.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="django.html#id55">})</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reference/modules.html">Module reference</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="../index.html" title="previous chapter">Dynaconf - Easy and Powerful Settings Configuration for Python</a></li>
      <li>Next: <a href="sensitive_secrets.html" title="next chapter">&lt;no title&gt;</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2015-2020, Bruno Rocha.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.0.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/guides/usage.md.txt"
          rel="nofollow">Page source</a>
    </div>

    
    <a href="https://github.com/rochacbruno/dynaconf" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
  </body>
</html>